# OOP
My Labs for OOP


It is my labs for OOP from my 2 year in KNURE.
At that moment it hasn't comments, but they will be added soon.

You can read task for each lab bellow on Russian:

Лабораторная работа №1:

Реализуйте и верифицируйте при помощи тестовой программы класс для моделирования состояния кофе-машины - CoffeeMachine. Должны поддерживаться следующие операции:

-Конструктор, принимающий максимальное количество зерен кофе в граммах (int), максимальный объем воды в миллилитрах (int), максимальное количество порций кофе, которые можно приготовить до заполнения бака с отходами после заваривания (int).

-Методы доступа к параметрам состояния машины:

-Масса оставшихся в машине зерен кофе.

-Объем оставшейся в машине воды.

-Количество порций кофе, которые можно приготовить до заполнения бака отходов.

-Метод загрузки зерен в машину, который пополняет текущий запас зерен до максимально возможного, и возвращает число зерен, которые фактически были погружены в машину.

-Аналогичный метод добавления воды в машину.

-Метод очистки бака с отходами.


-Метод приготовления кофе в соответствии с рецептом (эспрессо, американо) и крепостью (слабая, средняя, сильная), который:

--возвращает true в случае успеха приготовления;

--использует 4, 8 или 12 грамм кофе для одной порции соответственно крепости;

--использует 120 или 200 мл воды соответственно рецепту;

--создает 1 порцию отходов;

--отказывается варить кофе, если не хватает ресурсов либо заполнен бак отходов, при этом возвращая значение false.

-Метод приготовления двойной порции кофе, аналогичный предыдущему методу.

-Метод промывания кофе-машины, расходующий до 500 мл. воды, не вызывая ошибки, если столько воды в машине не оказывается.

-Перегруженный оператор преобразования к типу bool, определяющий способна ли машина приготовить хотя бы одну порцию кофе любой крепости по любому рецепту.

-Перегруженный глобальный оператор вывода в поток, печатающий информацию о состоянии кофе-машины в произвольной текстовой форме.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Лабораторная работа №2:

Создайте иерархию классов, моделирующих информацию о расписании поездов:


-класс Station (станция):

--название;

--количество перонов;


-класс TrainScheduleItem (пункт расписания поезда):

--станция, на которую должен прибыть поезд;

--время прибытия;

--время отправления;


-класс Route (маршрут):

--уникальный числовой номер;

--расписание (набор объектов TrainScheduleItem);


-класс Train (поезд):

--уникальный числовой номер;

--число пассажирских мест;

--маршрут, по которому в данный момент курсирует поезд.


-Напишите тестовую консольную программу, создающую и использующую данную модель:

--создать несколько станций, маршрутов и поездов;

--сформировать произвольное расписание маршрутов;

--распечатать 5 станций по убыванию, принимающих наиболее количество маршрутов (название станции, количество маршрутов, проходящих через станцию);

--распечатать 5 маршрутов с самым долгим временем в пути по убыванию (номер маршрута, начальная и конечная станции, длительность в пути);

--распечатать все пары станций, связанных более чем двумя маршрутами;

--распечатать станции, которые не связаны ни одним из маршрутов;

--распечатать станции, у которых в некоторое время суток не хватит свободных перонов для приема всех запланированных маршрутов;

--корректно уничтожить все объекты модели.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Лабораторная работа №3:


Создайте иерархию классов, моделирующих информацию о различных видах оплаты за потребление воды физическими лицами:

-абстрактный класс, представляющий потребителя воды (WaterConsumer), содержащий:

--уникальный идентификатор потребителя;

--полное имя потребителя;

--адрес потребителя;

--чисто виртуальный метод useWater, регистрирующий потребление указанного объема воды;

--чисто виртуальный метод getDebt, возвращающий сумму задолженности за потребленную воду за прошедший месяц, принимающий цену 1 куб. метра в качестве аргумента;


-производный класс, представляющий потребителя воды, оплачивающего счета в соответствии с показаниями индивидуального счетчика (CountingWaterConsumer):

--хранит объем воды в куб. метрах, потребленный с последнего момента оплаты;

--реализует метод useWater накоплением объема в этом счетчике;

--реализует метод getDebt умножением этого счетчика на цену 1 куб. метра воды;


-производный класс, представляющий потребителя воды, оплачивающего счета по установленным нормативам на душу населения (StandardWaterConsumer):

--хранит число зарегистрированных по адресу потребителя жителей;

--игнорирует вызовы useWater;

--реализует метод getDebt умножением цены 1 куб. метра воды на количество жителей и норматив потребления (объявите константу - 9 куб. м);


-производный класс, представляющий особого потребителя воды, живущего на государственные дотации (SubsidizedWaterConsumer):

--такой потребитель потребляет сколько угодно воды и ничего не платит;


Создайте текстовый файл “water_consumers.txt” с произвольной тестовой информацией о потребителях воды и с командами для манипулирования этой информацией в следующем формате:


COUNTED_PAYER id=”12345” name=”Ivanov” address=”Sumskaya, 1”

STANDARD_PAYER id=”23456” name=”Petrov” address=”Pushkinskaya, 1” users=”3”

SUBSIDIZED_PAYER id=”34567” name=”Sidorov” address=”Lenina, 1”


USE_WATER payer=”12345” amount=”5”

USE_WATER payer=”23456” amount=”5”

USE_WATER payer=”34567” amount=”5”

SHOW_DEBT payer=”12345” price=”2.448”

SHOW_DEBT payer=”23456” price=”2.448”

SHOW_DEBT payer=”34567” price=”2.448”


-Разработайте тестовую консольную программу, создающую и использующую данную модель:

--считайте данные о счетах из файла “water_consumers.txt”, сформируйте соответствующие объекты разработанной иерархии (команды COUNTED_PAYER, STANDARD_PAYER, SUBSIDIZED_PAYER);

--команда USE_WATER регистрирует использование указанным потребителем указанного объема воды (номер потребителя должен существовать, объем воды должен быть положительным - иначе, сгенерируйте сообщение об ошибке);

--команда SHOW_DEBT печатает на консоли задолженность указанного потребителя при указанной цене на 1 кубический метр воды (номер потребителя должен существовать, цена должна быть положительной - иначе, сгенерируйте сообщение об ошибке);

--корректно уничтожьте все созданные объекты.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Лабораторная работа №4:


Используя в качестве базовой идеи пример реализации циклического массива из лабораторной работы по дисциплине “Структуры и алгоритмы обработки данных” (integer_queue_circular_array_impl.hpp), создайте объектно-ориентированную и шаблонную версию данной реализации.


Реализация должна представлять из себя шаблон класса для очереди данного типа, принимающего тип хранящихся данных в качестве аргумента шаблона. Разработанный шаблон класса должен содержать:

-конструктор с аргументом, обозначающим размер массива, по умолчанию 10;

-деструктор;

-конструктор копий и перемещений;

-оператор присвоения и оператор перемещения;

-метод capacity для доступа к количеству выделенных ячеек;

-метод size для доступа к количеству занятых ячеек;

-методы empty и is_full для определения пустоты / полноты заполнения очереди;

-метод clear для очистки содержимого буфера;

-метод push для помещения элемента в конец очереди;

-метод front, который возвращает элемент, находящийся в начале очереди;

-метод pop для извлечения элемента, находящегося в начале очереди;

-методы begin/end, возвращающие объекты-итераторы, как в стандартных контейнерах (это потребует реализации некоторого вспомогательного класса-итератора, знающего особенности внутренней структуры разрабатываемого циклического массива).


Поскольку предсказать заранее с какими конкретными типами-аргументами будет использована данная структура не представляется возможным, реализация должна быть основана на модели включения (т.е., все методы должны быть реализованы в заголовочном файле, объявляющем шаблон класса).


Составьте тестовую программу и протестируйте реализацию как минимум на 3 различных типах-аргументах, среди которых должны быть представлены:

-любой встроенный тип;

-любой объект-значение, например Date, не содержащий ресурсов;

-объект std::string.


Протестируйте работу итераторов при помощи стандартных алгоритмов, например, for_each.
